/// <reference types="node" />
import { GetDecipher } from '@aws-crypto/material-management-node';
import { ContentType } from '@aws-crypto/serialize';
export interface DecipherInfo {
    messageId: Buffer;
    contentType: ContentType;
    getDecipher: GetDecipher;
    dispose: () => void;
}
export interface BodyInfo {
    iv: Buffer;
    contentLength: number;
    sequenceNumber: number;
    isFinalFrame: boolean;
}
export declare function getDecipherStream(): {
    _onBodyHeader: ({ iv, contentLength, sequenceNumber, isFinalFrame, }: BodyInfo) => void;
    _transform(chunk: any, _encoding: string, callback: Function): void;
    _read(size: number): void;
    _onAuthTag: (authTag: Buffer, next: Function) => Promise<void>;
    _destroy(): void;
    _flush(callback: import("stream").TransformCallback): void;
    readonly writable: boolean;
    readonly writableEnded: boolean;
    readonly writableFinished: boolean;
    readonly writableHighWaterMark: number;
    readonly writableLength: number;
    readonly writableObjectMode: boolean;
    readonly writableCorked: number;
    _write(chunk: any, encoding: string, callback: (error?: Error | null | undefined) => void): void;
    _writev?(chunks: {
        chunk: any;
        encoding: string;
    }[], callback: (error?: Error | null | undefined) => void): void;
    _final(callback: (error?: Error | null | undefined) => void): void;
    write(chunk: any, encoding?: string | undefined, cb?: ((error: Error | null | undefined) => void) | undefined): boolean;
    write(chunk: any, cb?: ((error: Error | null | undefined) => void) | undefined): boolean;
    setDefaultEncoding(encoding: string): any;
    end(cb?: (() => void) | undefined): void;
    end(chunk: any, cb?: (() => void) | undefined): void;
    end(chunk: any, encoding?: string | undefined, cb?: (() => void) | undefined): void;
    cork(): void;
    uncork(): void;
    readable: boolean;
    readonly readableHighWaterMark: number;
    readonly readableLength: number;
    readonly readableObjectMode: boolean;
    destroyed: boolean;
    read(size?: number | undefined): any;
    setEncoding(encoding: string): any;
    pause(): any;
    resume(): any;
    isPaused(): boolean;
    unpipe(destination?: NodeJS.WritableStream | undefined): any;
    unshift(chunk: any, encoding?: "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex" | undefined): void;
    wrap(oldStream: NodeJS.ReadableStream): any;
    push(chunk: any, encoding?: string | undefined): boolean;
    destroy(error?: Error | undefined): void;
    addListener(event: "close", listener: () => void): any;
    addListener(event: "data", listener: (chunk: any) => void): any;
    addListener(event: "end", listener: () => void): any;
    addListener(event: "error", listener: (err: Error) => void): any;
    addListener(event: "pause", listener: () => void): any;
    addListener(event: "readable", listener: () => void): any;
    addListener(event: "resume", listener: () => void): any;
    addListener(event: string | symbol, listener: (...args: any[]) => void): any;
    emit(event: "close"): boolean;
    emit(event: "data", chunk: any): boolean;
    emit(event: "end"): boolean;
    emit(event: "error", err: Error): boolean;
    emit(event: "pause"): boolean;
    emit(event: "readable"): boolean;
    emit(event: "resume"): boolean;
    emit(event: string | symbol, ...args: any[]): boolean;
    on(event: "close", listener: () => void): any;
    on(event: "data", listener: (chunk: any) => void): any;
    on(event: "end", listener: () => void): any;
    on(event: "error", listener: (err: Error) => void): any;
    on(event: "pause", listener: () => void): any;
    on(event: "readable", listener: () => void): any;
    on(event: "resume", listener: () => void): any;
    on(event: string | symbol, listener: (...args: any[]) => void): any;
    once(event: "close", listener: () => void): any;
    once(event: "data", listener: (chunk: any) => void): any;
    once(event: "end", listener: () => void): any;
    once(event: "error", listener: (err: Error) => void): any;
    once(event: "pause", listener: () => void): any;
    once(event: "readable", listener: () => void): any;
    once(event: "resume", listener: () => void): any;
    once(event: string | symbol, listener: (...args: any[]) => void): any;
    prependListener(event: "close", listener: () => void): any;
    prependListener(event: "data", listener: (chunk: any) => void): any;
    prependListener(event: "end", listener: () => void): any;
    prependListener(event: "error", listener: (err: Error) => void): any;
    prependListener(event: "pause", listener: () => void): any;
    prependListener(event: "readable", listener: () => void): any;
    prependListener(event: "resume", listener: () => void): any;
    prependListener(event: string | symbol, listener: (...args: any[]) => void): any;
    prependOnceListener(event: "close", listener: () => void): any;
    prependOnceListener(event: "data", listener: (chunk: any) => void): any;
    prependOnceListener(event: "end", listener: () => void): any;
    prependOnceListener(event: "error", listener: (err: Error) => void): any;
    prependOnceListener(event: "pause", listener: () => void): any;
    prependOnceListener(event: "readable", listener: () => void): any;
    prependOnceListener(event: "resume", listener: () => void): any;
    prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): any;
    removeListener(event: "close", listener: () => void): any;
    removeListener(event: "data", listener: (chunk: any) => void): any;
    removeListener(event: "end", listener: () => void): any;
    removeListener(event: "error", listener: (err: Error) => void): any;
    removeListener(event: "pause", listener: () => void): any;
    removeListener(event: "readable", listener: () => void): any;
    removeListener(event: "resume", listener: () => void): any;
    removeListener(event: string | symbol, listener: (...args: any[]) => void): any;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    pipe<T extends NodeJS.WritableStream>(destination: T, options?: {
        end?: boolean | undefined;
    } | undefined): T;
    off(event: string | symbol, listener: (...args: any[]) => void): any;
    removeAllListeners(event?: string | symbol | undefined): any;
    setMaxListeners(n: number): any;
    getMaxListeners(): number;
    listeners(event: string | symbol): Function[];
    rawListeners(event: string | symbol): Function[];
    listenerCount(type: string | symbol): number;
    eventNames(): (string | symbol)[];
};
//# sourceMappingURL=decipher_stream.d.ts.map