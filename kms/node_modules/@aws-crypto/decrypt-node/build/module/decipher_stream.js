// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// @ts-ignore
import { Transform as PortableTransform } from 'readable-stream';
import { needs, } from '@aws-crypto/material-management-node';
import { aadFactory } from '@aws-crypto/serialize';
import { VerifyStream } from './verify_stream';
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const aadUtility = aadFactory(fromUtf8);
const PortableTransformWithType = PortableTransform;
const ioTick = async () => new Promise((resolve) => setImmediate(resolve));
const noop = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
export function getDecipherStream() {
    let decipherInfo;
    let decipherState = {};
    let pathologicalDrain = noop;
    let frameComplete = false;
    return new (class DecipherStream extends PortableTransformWithType {
        constructor() {
            super();
            this._onBodyHeader = ({ iv, contentLength, sequenceNumber, isFinalFrame, }) => {
                /* Precondition: decipherInfo must be set before BodyInfo is sent. */
                needs(decipherInfo, 'Malformed State.');
                /* Precondition: Ciphertext must not be flowing before a BodyHeader is processed. */
                needs(!decipherState.decipher, 'Malformed State.');
                const { messageId, contentType, getDecipher } = decipherInfo;
                const aadString = aadUtility.messageAADContentString({
                    contentType,
                    isFinalFrame,
                });
                const messageAAD = aadUtility.messageAAD(messageId, aadString, sequenceNumber, contentLength);
                const decipher = getDecipher(iv).setAAD(Buffer.from(messageAAD.buffer, messageAAD.byteOffset, messageAAD.byteLength));
                const content = [];
                decipherState = { decipher, content, contentLength };
            };
            this._onAuthTag = async (authTag, next) => {
                const { decipher, content, contentLength } = decipherState;
                /* Precondition: _onAuthTag must be called only after a frame has been accumulated.
                 * However there is an edge case.  The final frame _can_ be zero length.
                 * This means that _transform will never be called.
                 */
                needs(frameComplete || contentLength === 0, 'AuthTag before frame.');
                /* Precondition UNTESTED: I must have received all content for this frame.
                 * Both contentLength and frameComplete are private variables.
                 * As such manipulating them separately outside of the _transform function
                 * should not be possible.
                 * I do not know of this condition would ever be false while the above is true.
                 * But I do not want to remove the check as there may be a more complicated case
                 * that makes this possible.
                 * If such a case is found.
                 * Write a test.
                 */
                needs(contentLength === 0, 'Lengths do not match');
                // flush content from state.
                decipherState = {};
                decipher.setAuthTag(authTag);
                /* In Node.js versions 10.9 and older will fail to decrypt if decipher.update is not called.
                 * https://github.com/nodejs/node/pull/22538 fixes this.
                 */
                if (!content.length)
                    decipher.update(Buffer.alloc(0));
                const clear = [];
                for (const cipherChunk of content) {
                    const clearChunk = decipher.update(cipherChunk);
                    clear.push(clearChunk);
                    await ioTick();
                }
                // If the authTag is not valid this will throw
                const tail = decipher.final();
                clear.push(tail);
                for (const clearChunk of clear) {
                    if (!this.push(clearChunk)) {
                        /* back pressure: if push returns false, wait until _read
                         * has been called.
                         */
                        await new Promise((resolve) => {
                            pathologicalDrain = resolve;
                        });
                    }
                }
                /* This frame is complete.
                 * Need to notify the VerifyStream continue.
                 * See the note in `AuthTag` for details.
                 * The short answer is that for small frame sizes,
                 * the "next" frame associated auth tag may be
                 * parsed and send before the "current" is processed.
                 * This will cause the auth tag event to fire before
                 * any _transform events fire and a 'Lengths do not match' precondition to fail.
                 */
                next();
                // This frame is complete. Notify _transform to continue, see needs above for more details
                if (frameComplete)
                    frameComplete();
                // reset for next frame.
                frameComplete = false;
            };
            this.on('pipe', (source) => {
                /* Precondition: The source must be a VerifyStream to emit the required events. */
                needs(source instanceof VerifyStream, 'Unsupported source');
                source
                    .once('DecipherInfo', (info) => {
                    decipherInfo = info;
                })
                    .on('BodyInfo', this._onBodyHeader)
                    .on('AuthTag', (authTag, next) => {
                    this._onAuthTag(authTag, next).catch((e) => this.emit('error', e));
                });
            });
        }
        _transform(chunk, _encoding, callback) {
            /* Precondition: BodyHeader must be parsed before frame data. */
            needs(decipherState.decipher, 'Malformed State.');
            decipherState.contentLength -= chunk.length;
            /* Precondition: Only content should be transformed, so the lengths must always match.
             * The BodyHeader and AuthTag are striped in the VerifyStream and passed in
             * through events.  This means that if I receive a chunk without havening reset
             * the content accumulation events are out of order.  Panic.
             */
            needs(decipherState.contentLength >= 0, 'Lengths do not match');
            const { content } = decipherState;
            content.push(chunk);
            if (decipherState.contentLength > 0) {
                // More data to this frame
                callback();
            }
            else {
                // The frame is full, waiting for `AuthTag`
                // event to decrypt and forward the clear frame
                frameComplete = callback;
            }
        }
        _read(size) {
            /* The _onAuthTag decrypts and pushes the encrypted frame.
             * If this.push returns false then this stream
             * should wait until the destination stream calls read.
             * This means that _onAuthTag needs to wait for some
             * indeterminate time.  I create a closure around
             * the resolution function for a promise that
             * is created in _onAuthTag.  This way
             * here in _read (the implementation of read)
             * if a frame is being pushed, we can release
             * it.
             */
            pathologicalDrain();
            pathologicalDrain = noop;
            super._read(size);
        }
        _destroy() {
            // It is possible to have to destroy the stream before
            // decipherInfo is set.  Especially if the HeaderAuth
            // is not valid.
            decipherInfo && decipherInfo.dispose();
        }
    })();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjaXBoZXJfc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RlY2lwaGVyX3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDO0FBRXRDLGFBQWE7QUFDYixPQUFPLEVBQUUsU0FBUyxJQUFJLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUE7QUFFaEUsT0FBTyxFQUNMLEtBQUssR0FHTixNQUFNLHNDQUFzQyxDQUFBO0FBQzdDLE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSx1QkFBdUIsQ0FBQTtBQUMvRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUE7QUFFOUMsTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFBO0FBQzlELE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUN2QyxNQUFNLHlCQUF5QixHQUFHLGlCQUVwQixDQUFBO0FBc0JkLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBO0FBQzFFLE1BQU0sSUFBSSxHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQSxDQUFDLDJEQUEyRDtBQUVqRixNQUFNLFVBQVUsaUJBQWlCO0lBQy9CLElBQUksWUFBMEIsQ0FBQTtJQUM5QixJQUFJLGFBQWEsR0FBa0IsRUFBUyxDQUFBO0lBQzVDLElBQUksaUJBQWlCLEdBQWEsSUFBSSxDQUFBO0lBQ3RDLElBQUksYUFBYSxHQUFxQixLQUFLLENBQUE7SUFFM0MsT0FBTyxJQUFJLENBQUMsTUFBTSxjQUFlLFNBQVEseUJBQXlCO1FBQ2hFO1lBQ0UsS0FBSyxFQUFFLENBQUE7WUFlVCxr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