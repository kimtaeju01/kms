"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const material_management_node_1 = require("@aws-crypto/material-management-node");
const crypto_1 = require("crypto");
const serialize_1 = require("@aws-crypto/serialize");
const raw_keyring_1 = require("@aws-crypto/raw-keyring");
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const toUtf8 = (input) => Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString('utf8');
const { serializeEncryptionContext } = serialize_1.serializeFactory(fromUtf8);
const { rawAesEncryptedDataKey } = raw_keyring_1.rawAesEncryptedDataKeyFactory(toUtf8, fromUtf8);
const { rawAesEncryptedParts } = raw_keyring_1.rawAesEncryptedPartsFactory(fromUtf8);
class RawAesKeyringNode extends material_management_node_1.KeyringNode {
    constructor(input) {
        super();
        this._onEncrypt = raw_keyring_1._onEncrypt(randomBytesAsync);
        this._onDecrypt = raw_keyring_1._onDecrypt();
        const { keyName, keyNamespace, unencryptedMasterKey, wrappingSuite } = input;
        /* Precondition: AesKeyringNode needs identifying information for encrypt and decrypt. */
        material_management_node_1.needs(keyName && keyNamespace, 'Identifying information must be defined.');
        /* Precondition: RawAesKeyringNode requires wrappingSuite to be a valid RawAesWrappingSuite. */
        const wrappingMaterial = new raw_keyring_1.NodeRawAesMaterial(wrappingSuite)
            /* Precondition: unencryptedMasterKey must correspond to the NodeAlgorithmSuite specification.
             * Note: the KeyringTrace and flag are _only_ set because I am reusing an existing implementation.
             * See: raw_aes_material.ts in @aws-crypto/raw-keyring for details
             */
            .setUnencryptedDataKey(unencryptedMasterKey, {
            keyNamespace,
            keyName,
            flags: material_management_node_1.KeyringTraceFlag.WRAPPING_KEY_GENERATED_DATA_KEY,
        });
        const _wrapKey = async (material) => {
            /* The AAD section is uInt16BE(length) + AAD
             * see: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-aad
             * However, the RAW Keyring wants _only_ the ADD.
             * So, I just slice off the length.
             */
            const { buffer, byteOffset, byteLength } = serializeEncryptionContext(material.encryptionContext).slice(2);
            const aad = Buffer.from(buffer, byteOffset, byteLength);
            const { keyNamespace, keyName } = this;
            return aesGcmWrapKey(keyNamespace, keyName, material, aad, wrappingMaterial);
        };
        const _unwrapKey = async (material, edk) => {
            const { keyNamespace, keyName } = this;
            /* The AAD section is uInt16BE(length) + AAD
             * see: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-aad
             * However, the RAW Keyring wants _only_ the ADD.
             * So, I just slice off the length.
             */
            const { buffer, byteOffset, byteLength } = serializeEncryptionContext(material.encryptionContext).slice(2);
            const aad = Buffer.from(buffer, byteOffset, byteLength);
            // const aad = Buffer.concat(encodeEncryptionContext(context || {}))
            return aesGcmUnwrapKey(keyNamespace, keyName, material, wrappingMaterial, edk, aad);
        };
        material_management_node_1.readOnlyProperty(this, 'keyName', keyName);
        material_management_node_1.readOnlyProperty(this, 'keyNamespace', keyNamespace);
        material_management_node_1.readOnlyProperty(this, '_wrapKey', _wrapKey);
        material_management_node_1.readOnlyProperty(this, '_unwrapKey', _unwrapKey);
    }
    _filter({ providerId, providerInfo }) {
        const { keyNamespace, keyName } = this;
        return providerId === keyNamespace && providerInfo.startsWith(keyName);
    }
}
exports.RawAesKeyringNode = RawAesKeyringNode;
material_management_node_1.immutableClass(RawAesKeyringNode);
const encryptFlags = material_management_node_1.KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY |
    material_management_node_1.KeyringTraceFlag.WRAPPING_KEY_SIGNED_ENC_CTX;
const decryptFlags = material_management_node_1.KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY |
    material_management_node_1.KeyringTraceFlag.WRAPPING_KEY_VERIFIED_ENC_CTX;
/**
 * Uses aes-gcm to encrypt the data key and return the passed NodeEncryptionMaterial with
 * an EncryptedDataKey added.
 * @param keyNamespace [String] The keyring namespace (for KeyringTrace)
 * @param keyName [String] The keyring name (for KeyringTrace and to extract the extra info stored in providerInfo)
 * @param material [NodeEncryptionMaterial] The target material to which the EncryptedDataKey will be added
 * @param aad [Buffer] The serialized aad (EncryptionContext)
 * @param wrappingMaterial [NodeRawAesMaterial] The material used to decrypt the EncryptedDataKey
 * @returns [NodeEncryptionMaterial] Mutates and returns the same NodeEncryptionMaterial that was passed but with an EncryptedDataKey added
 */
function aesGcmWrapKey(keyNamespace, keyName, material, aad, wrappingMaterial) {
    const { encryption, ivLength } = wrappingMaterial.suite;
    const iv = crypto_1.randomBytes(ivLength);
    const wrappingDataKey = wrappingMaterial.getUnencryptedDataKey();
    const dataKey = material_management_node_1.unwrapDataKey(material.getUnencryptedDataKey());
    const cipher = crypto_1.createCipheriv(encryption, wrappingDataKey, iv).setAAD(aad);
    // Buffer.concat will use the shared buffer space, and the resultant buffer will have a byteOffset...
    const ciphertext = serialize_1.concatBuffers(cipher.update(dataKey), cipher.final());
    const authTag = cipher.getAuthTag();
    const edk = rawAesEncryptedDataKey(keyNamespace, keyName, iv, ciphertext, authTag);
    return material.addEncryptedDataKey(edk, encryptFlags);
}
/**
 * Uses aes-gcm to decrypt the encrypted data key and return the passed NodeDecryptionMaterial with
 * the unencrypted data key set.
 * @param keyNamespace [String] The keyring namespace (for KeyringTrace)
 * @param keyName [String] The keyring name (for KeyringTrace and to extract the extra info stored in providerInfo)
 * @param material [NodeDecryptionMaterial] The target material to which the decrypted data key will be added
 * @param wrappingMaterial [NodeRawAesMaterial] The material used to decrypt the EncryptedDataKey
 * @param edk [EncryptedDataKey] The EncryptedDataKey on which to operate
 * @param aad [Buffer] The serialized aad (EncryptionContext)
 * @returns [NodeDecryptionMaterial] Mutates and returns the same NodeDecryptionMaterial that was passed but with the unencrypted data key set
 */
function aesGcmUnwrapKey(keyNamespace, keyName, material, wrappingMaterial, edk, aad) {
    const { authTag, ciphertext, iv } = rawAesEncryptedParts(material.suite, keyName, edk);
    const { encryption } = wrappingMaterial.suite;
    // createDecipheriv is incorrectly typed in @types/node. It should take key: CipherKey, not key: BinaryLike
    const decipher = crypto_1.createDecipheriv(encryption, wrappingMaterial.getUnencryptedDataKey(), iv)
        .setAAD(aad)
        .setAuthTag(authTag);
    // Buffer.concat will use the shared buffer space, and the resultant buffer will have a byteOffset...
    const unencryptedDataKey = serialize_1.concatBuffers(decipher.update(ciphertext), decipher.final());
    const trace = { keyNamespace, keyName, flags: decryptFlags };
    return material.setUnencryptedDataKey(unencryptedDataKey, trace);
}
async function randomBytesAsync(size) {
    return new Promise((resolve, reject) => {
        crypto_1.randomBytes(size, (err, buffer) => {
            if (err)
                return reject(err);
            resolve(buffer);
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X2Flc19rZXlyaW5nX25vZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcmF3X2Flc19rZXlyaW5nX25vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7O0FBRXRDLG1GQVc2QztBQUM3QyxtQ0FBc0U7QUFDdEUscURBQXVFO0FBQ3ZFLHlEQVNnQztBQUNoQyxNQUFNLFFBQVEsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUE7QUFDOUQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFpQixFQUFFLEVBQUUsQ0FDbkMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtBQUNoRixNQUFNLEVBQUUsMEJBQTBCLEVBQUUsR0FBRyw0QkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUNqRSxNQUFNLEVBQUUsc0JBQXNCLEVBQUUsR0FBRywyQ0FBNkIsQ0FDOUQsTUFBTSxFQUNOLFFBQVEsQ0FDVCxDQUFBO0FBQ0QsTUFBTSxFQUFFLG9CQUFvQixFQUFFLEdBQUcseUNBQTJCLENBQUMsUUFBUSxDQUFDLENBQUE7QUFTdEUsTUFBYSxpQkFBa0IsU0FBUSxzQ0FBVztJQU1oRCxZQUFZLEtBQTZCO1FBQ3ZDLEtBQUssRUFBRSxDQUFBO1FBMkVULGVBQVUsR0FBRyx3QkFBVSxDQUNyQixnQkFBZ0IsQ0FDakIsQ0FBQTtRQUNELGVBQVUsR0FBRyx3QkFBVSxFQUF5QyxDQUFBO1FBNUU5RCxNQUFNLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxhQUFhLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDNUUseUZBQXlGO1FBQ3pGLGdDQUFLLENBQUMs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