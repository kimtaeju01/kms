"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const material_management_1 = require("@aws-crypto/material-management");
const crypto_1 = require("crypto");
const hkdf_node_1 = require("@aws-crypto/hkdf-node");
const kdfIndex = Object.freeze({
    sha256: hkdf_node_1.HKDF('sha256'),
    sha384: hkdf_node_1.HKDF('sha384'),
});
exports.getEncryptHelper = (material) => {
    /* Precondition: NodeEncryptionMaterial must have a valid data key. */
    material_management_1.needs(material.hasValidKey(), 'Material has no unencrypted data key.');
    const { signatureHash } = material.suite;
    /* Conditional types can not narrow the return type :(
     * Function overloads "works" but then I can not export
     * the function and have eslint be happy (Multiple exports of name)
     */
    const kdfGetCipher = getCryptoStream(material);
    return Object.freeze({
        kdfGetCipher,
        getSigner: signatureHash ? getSigner : undefined,
        dispose,
    });
    function getSigner() {
        /* Precondition: The NodeEncryptionMaterial must have not been zeroed.
         * hasUnencryptedDataKey will check that the unencrypted data key has been set
         * *and* that it has not been zeroed.  At this point it must have been set
         * because the KDF function operated on it.  So at this point
         * we are protecting that someone has zeroed out the material
         * because the Encrypt process has been complete.
         */
        material_management_1.needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
        if (!signatureHash)
            throw new Error('Material does not support signature.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Material does not support signature.');
        const { privateKey } = signatureKey;
        if (typeof privateKey !== 'string')
            throw new Error('Material does not support signature.');
        const signer = Object.assign(crypto_1.createSign(signatureHash), 
        // don't export the private key if we don't have to
        { awsCryptoSign: () => signer.sign(privateKey) });
        return signer;
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
exports.getDecryptionHelper = (material) => {
    /* Precondition: NodeDecryptionMaterial must have a valid data key. */
    material_management_1.needs(material.hasValidKey(), 'Material has no unencrypted data key.');
    const { signatureHash } = material.suite;
    /* Conditional types can not narrow the return type :(
     * Function overloads "works" but then I can not export
     * the function and have eslint be happy (Multiple exports of name)
     */
    const kdfGetDecipher = getCryptoStream(material);
    return Object.freeze({
        kdfGetDecipher,
        getVerify: signatureHash ? getVerify : undefined,
        dispose,
    });
    function getVerify() {
        if (!signatureHash)
            throw new Error('Material does not support signature.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Material does not support signature.');
        const verify = Object.assign(crypto_1.createVerify(signatureHash), 
        // explicitly bind the public key for this material
        {
            awsCryptoVerify: (signature) => verify.verify(verificationKey.publicKey, signature),
        });
        return verify;
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
function getCryptoStream(material) {
    const { encryption: cipherName, ivLength } = material.suite;
    const createCryptoStream = material instanceof material_management_1.NodeEncryptionMaterial
        ? crypto_1.createCipheriv
        : material instanceof material_management_1.NodeDecryptionMaterial
            ? crypto_1.createDecipheriv
            : false;
    /* Precondition: material must be either NodeEncryptionMaterial or NodeDecryptionMaterial. */
    if (!createCryptoStream)
        throw new Error('Unsupported cryptographic material.');
    return (info) => {
        const derivedKey = nodeKdf(material, info);
        return (iv) => {
            /* Precondition: The length of the IV must match the NodeAlgorithmSuite specification. */
            material_management_1.needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            /* Precondition: The material must have not been zeroed.
             * hasUnencryptedDataKey will check that the unencrypted data key has been set
             * *and* that it has not been zeroed.  At this point it must have been set
             * because the KDF function operated on it.  So at this point
             * we are protecting that someone has zeroed out the material
             * because the Encrypt process has been complete.
             */
            material_management_1.needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
            // createDecipheriv is incorrectly typed in @types/node. It should take key: CipherKey, not key: BinaryLike
            return createCryptoStream(cipherName, derivedKey, iv);
        };
    };
}
exports.getCryptoStream = getCryptoStream;
function nodeKdf(material, info) {
    const dataKey = material.getUnencryptedDataKey();
    const { kdf, kdfHash, keyLengthBytes } = material.suite;
    /* Check for early return (Postcondition): No Node.js KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash)
        return dataKey;
    /* Precondition: Valid HKDF values must exist for Node.js. */
    material_management_1.needs(kdf === 'HKDF' &&
        kdfHash &&
        kdfIndex[kdfHash] &&
        info instanceof Uint8Array, 'Invalid HKDF values.');
    /* The unwrap is done once we *know* that a KDF is required.
     * If we unwrapped before everything will work,
     * but we may be creating new copies of the unencrypted data key (export).
     */
    const { buffer: dkBuffer, byteOffset: dkByteOffset, byteLength: dkByteLength, } = material_management_1.unwrapDataKey(dataKey);
    // info and kdfHash are now defined
    const toExtract = Buffer.from(dkBuffer, dkByteOffset, dkByteLength);
    const { buffer, byteOffset, byteLength } = info;
    const infoBuff = Buffer.from(buffer, byteOffset, byteLength);
    const derivedBytes = kdfIndex[kdfHash](toExtract)(keyLengthBytes, infoBuff);
    return material_management_1.wrapWithKeyObjectIfSupported(derivedBytes);
}
exports.nodeKdf = nodeKdf;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDOztBQUV0Qyx5RUFRd0M7QUFDeEMsbUNBT2U7QUFDZixxREFBNEM7QUFpQjVDLE1BQU0sUUFBUSxHQUFhLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDdkMsTUFBTSxFQUFFLGdCQUFJLENBQUMsUUFBb0IsQ0FBQztJQUNsQyxNQUFNLEVBQUUsZ0JBQUksQ0FBQyxRQUFvQixDQUFDO0NBQ25DLENBQUMsQ0FBQTtBQXdCVyxRQUFBLGdCQUFnQixHQUFxQixDQUNoRCxRQUFnQyxFQUNoQyxFQUFFO0lBQ0Ysc0VBQXNFO0lBQ3RFLDJCQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxFQUFFLHVDQUF1QyxDQUFDLENBQUE7SUFFdEUsTUFBTSxFQUFFLGFBQWEsRUFBRSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUE7SUFDeEM7OztPQUdHO0lBQ0gsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBbUIsQ0FBQTtJQUNoRSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDbkIsWUFBWTtRQUNaLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUztRQUNoRCxPQUFPO0tBQ1IsQ0FBQyxDQUFBO0lBRUYsU0FBUyxTQUFTO1FBQ2hCOzs7Ozs7V0FNRztRQUNILDJCQUFLLENBQ0gsUUFBUSxDQUFDLHFCQUFxQixFQUM5Qix1Q0FBdUMsQ0FDeEMsQ0FBQTtRQUVELElBQUksQ0FBQyxhQUFhO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFBO1FBQzNFLE1BQU0sRUFBRSxZQUFZLEVBQUUsR0FBRyxRQUFRLENBQUE7UUFDakMsSUFBSSxDQUFDLFlBQVk7WUFBRSxNQUFN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