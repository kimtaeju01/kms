// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { needs, NodeEncryptionMaterial, NodeDecryptionMaterial, unwrapDataKey, wrapWithKeyObjectIfSupported, } from '@aws-crypto/material-management';
import { createCipheriv, createDecipheriv, createSign, createVerify, } from 'crypto';
import { HKDF } from '@aws-crypto/hkdf-node';
const kdfIndex = Object.freeze({
    sha256: HKDF('sha256'),
    sha384: HKDF('sha384'),
});
export const getEncryptHelper = (material) => {
    /* Precondition: NodeEncryptionMaterial must have a valid data key. */
    needs(material.hasValidKey(), 'Material has no unencrypted data key.');
    const { signatureHash } = material.suite;
    /* Conditional types can not narrow the return type :(
     * Function overloads "works" but then I can not export
     * the function and have eslint be happy (Multiple exports of name)
     */
    const kdfGetCipher = getCryptoStream(material);
    return Object.freeze({
        kdfGetCipher,
        getSigner: signatureHash ? getSigner : undefined,
        dispose,
    });
    function getSigner() {
        /* Precondition: The NodeEncryptionMaterial must have not been zeroed.
         * hasUnencryptedDataKey will check that the unencrypted data key has been set
         * *and* that it has not been zeroed.  At this point it must have been set
         * because the KDF function operated on it.  So at this point
         * we are protecting that someone has zeroed out the material
         * because the Encrypt process has been complete.
         */
        needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
        if (!signatureHash)
            throw new Error('Material does not support signature.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Material does not support signature.');
        const { privateKey } = signatureKey;
        if (typeof privateKey !== 'string')
            throw new Error('Material does not support signature.');
        const signer = Object.assign(createSign(signatureHash), 
        // don't export the private key if we don't have to
        { awsCryptoSign: () => signer.sign(privateKey) });
        return signer;
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
export const getDecryptionHelper = (material) => {
    /* Precondition: NodeDecryptionMaterial must have a valid data key. */
    needs(material.hasValidKey(), 'Material has no unencrypted data key.');
    const { signatureHash } = material.suite;
    /* Conditional types can not narrow the return type :(
     * Function overloads "works" but then I can not export
     * the function and have eslint be happy (Multiple exports of name)
     */
    const kdfGetDecipher = getCryptoStream(material);
    return Object.freeze({
        kdfGetDecipher,
        getVerify: signatureHash ? getVerify : undefined,
        dispose,
    });
    function getVerify() {
        if (!signatureHash)
            throw new Error('Material does not support signature.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Material does not support signature.');
        const verify = Object.assign(createVerify(signatureHash), 
        // explicitly bind the public key for this material
        {
            awsCryptoVerify: (signature) => verify.verify(verificationKey.publicKey, signature),
        });
        return verify;
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
export function getCryptoStream(material) {
    const { encryption: cipherName, ivLength } = material.suite;
    const createCryptoStream = material instanceof NodeEncryptionMaterial
        ? createCipheriv
        : material instanceof NodeDecryptionMaterial
            ? createDecipheriv
            : false;
    /* Precondition: material must be either NodeEncryptionMaterial or NodeDecryptionMaterial. */
    if (!createCryptoStream)
        throw new Error('Unsupported cryptographic material.');
    return (info) => {
        const derivedKey = nodeKdf(material, info);
        return (iv) => {
            /* Precondition: The length of the IV must match the NodeAlgorithmSuite specification. */
            needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            /* Precondition: The material must have not been zeroed.
             * hasUnencryptedDataKey will check that the unencrypted data key has been set
             * *and* that it has not been zeroed.  At this point it must have been set
             * because the KDF function operated on it.  So at this point
             * we are protecting that someone has zeroed out the material
             * because the Encrypt process has been complete.
             */
            needs(material.hasUnencryptedDataKey, 'Unencrypted data key has been zeroed.');
            // createDecipheriv is incorrectly typed in @types/node. It should take key: CipherKey, not key: BinaryLike
            return createCryptoStream(cipherName, derivedKey, iv);
        };
    };
}
export function nodeKdf(material, info) {
    const dataKey = material.getUnencryptedDataKey();
    const { kdf, kdfHash, keyLengthBytes } = material.suite;
    /* Check for early return (Postcondition): No Node.js KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash)
        return dataKey;
    /* Precondition: Valid HKDF values must exist for Node.js. */
    needs(kdf === 'HKDF' &&
        kdfHash &&
        kdfIndex[kdfHash] &&
        info instanceof Uint8Array, 'Invalid HKDF values.');
    /* The unwrap is done once we *know* that a KDF is required.
     * If we unwrapped before everything will work,
     * but we may be creating new copies of the unencrypted data key (export).
     */
    const { buffer: dkBuffer, byteOffset: dkByteOffset, byteLength: dkByteLength, } = unwrapDataKey(dataKey);
    // info and kdfHash are now defined
    const toExtract = Buffer.from(dkBuffer, dkByteOffset, dkByteLength);
    const { buffer, byteOffset, byteLength } = info;
    const infoBuff = Buffer.from(buffer, byteOffset, byteLength);
    const derivedBytes = kdfIndex[kdfHash](toExtract)(keyLengthBytes, infoBuff);
    return wrapWithKeyObjectIfSupported(derivedBytes);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9FQUFvRTtBQUNwRSxzQ0FBc0M7QUFFdEMsT0FBTyxFQUNMLEtBQUssRUFDTCxzQkFBc0IsRUFDdEIsc0JBQXNCLEVBQ3RCLGFBQWEsRUFDYiw0QkFBNEIsR0FHN0IsTUFBTSxpQ0FBaUMsQ0FBQTtBQUN4QyxPQUFPLEVBR0wsY0FBYyxFQUNkLGdCQUFnQixFQUNoQixVQUFVLEVBQ1YsWUFBWSxHQUNiLE1BQU0sUUFBUSxDQUFBO0FBQ2YsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLHVCQUF1QixDQUFBO0FBaUI1QyxNQUFNLFFBQVEsR0FBYSxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3ZDLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBb0IsQ0FBQztJQUNsQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQW9CLENBQUM7Q0FDbkMsQ0FBQyxDQUFBO0FBd0JGLE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFxQixDQUNoRCxRQUFnQyxFQUNoQyxFQUFFO0lBQ0Ysc0VBQXNFO0lBQ3RFLEtBQUssQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLEVBQUUsdUNBQXVDLENBQUMsQ0FBQTtJQUV0RSxNQUFNLEVBQUUsYUFBYSxFQUFFLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQTtJQUN4Qzs7O09BR0c7SUFDSCxNQUFNLFlBQVksR0FBRyxlQUFlLENBQUMsUUFBUSxDQUFtQixDQUFBO0lBQ2hFLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNuQixZQUFZO1FBQ1osU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTO1FBQ2hELE9BQU87S0FDUixDQUFDLENBQUE7SUFFRixTQUFTLFNBQVM7UUFDaEI7Ozs7OztXQU1HO1FBQ0gsS0FBSyxDQUNI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