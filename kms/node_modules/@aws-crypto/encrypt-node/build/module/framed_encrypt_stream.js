// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { serializeFactory, aadFactory, Maximum, } from '@aws-crypto/serialize';
// @ts-ignore
import { Transform as PortableTransform } from 'readable-stream';
import { needs, } from '@aws-crypto/material-management-node';
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const serialize = serializeFactory(fromUtf8);
const { finalFrameHeader, frameHeader } = serialize;
const aadUtility = aadFactory(fromUtf8);
const PortableTransformWithType = PortableTransform;
const ioTick = async () => new Promise((resolve) => setImmediate(resolve));
const noop = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
export function getFramedEncryptStream(getCipher, messageHeader, dispose, plaintextLength) {
    let accumulatingFrame = {
        contentLength: 0,
        content: [],
        sequenceNumber: 1,
    };
    let pathologicalDrain = noop;
    const { frameLength } = messageHeader;
    /* Precondition: plaintextLength must be within bounds.
     * The Maximum.BYTES_PER_MESSAGE is set to be within Number.MAX_SAFE_INTEGER
     * See serialize/identifiers.ts enum Maximum for more details.
     */
    needs(!plaintextLength ||
        (plaintextLength >= 0 && Maximum.BYTES_PER_MESSAGE >= plaintextLength), 'plaintextLength out of bounds.');
    /* Keeping the messageHeader, accumulatingFrame and pathologicalDrain private is the intention here.
     * It is already unlikely that these values could be touched in the current composition of streams,
     * but a different composition may change this.
     * Since we are handling the plain text here, it seems prudent to take extra measures.
     */
    return new (class FramedEncryptStream extends PortableTransformWithType {
        _transform(chunk, encoding, callback) {
            const contentLeft = frameLength - accumulatingFrame.contentLength;
            /* Precondition: Must not process more than plaintextLength.
             * The plaintextLength is the MAXIMUM value that can be encrypted.
             */
            needs(!plaintextLength || (plaintextLength -= chunk.length) >= 0, 'Encrypted data exceeded plaintextLength.');
            /* Check for early return (Postcondition): Have not accumulated a frame. */
            if (contentLeft > chunk.length) {
                // eat more
                accumulatingFrame.contentLength += chunk.length;
                accumulatingFrame.content.push(chunk);
                return callback();
            }
            accumulatingFrame.contentLength += contentLeft;
            accumulatingFrame.content.push(chunk.slice(0, contentLeft));
            // grab the tail
            const tail = chunk.slice(contentLeft);
            const encryptFrame = getEncryptFrame({
                pendingFrame: accumulatingFrame,
                messageHeader,
                getCipher,
                isFinalFrame: false,
            });
            // Reset frame state for next frame
            const { sequenceNumber } = accumulatingFrame;
            accumulatingFrame = {
                contentLength: 0,
                content: [],
                sequenceNumber: sequenceNumber + 1,
            };
            this._flushEncryptFrame(encryptFrame)
                .then(() => this._transform(tail, encoding, callback))
                .catch(callback);
        }
        _flush(callback) {
            const encryptFrame = getEncryptFrame({
                pendingFrame: accumulatingFrame,
                messageHeader,
                getCipher,
                isFinalFrame: true,
            });
            this._flushEncryptFrame(encryptFrame)
                .then(() => callback())
                .catch(callback);
        }
        _destroy() {
            dispose();
        }
        _read(size) {
            super._read(size);
            /* The _flushEncryptFrame encrypts and pushes the frame.
             * If this.push returns false then this stream
             * should wait until the destination stream calls read.
             * This means that _flushEncryptFrame needs to wait for some
             * indeterminate time.  I create a closure around
             * the resolution function for a promise that
             * is created in _flushEncryptFrame.  This way
             * here in _read (the implementation of read)
             * if a frame is being pushed, we can release
             * it.
             */
            pathologicalDrain();
            pathologicalDrain = noop;
        }
        async _flushEncryptFrame(encryptingFrame) {
            const { content, cipher, bodyHeader, isFinalFrame } = encryptingFrame;
            this.push(bodyHeader);
            let frameSize = 0;
            const cipherContent = [];
            for (const clearChunk of content) {
                const cipherText = cipher.update(clearChunk);
                frameSize += cipherText.length;
                cipherContent.push(cipherText);
                await ioTick();
            }
            /* Finalize the cipher and handle any tail. */
            const tail = cipher.final();
            frameSize += tail.length;
            cipherContent.push(tail);
            /* Push the authTag onto the end.  Yes, I am abusing the name. */
            cipherContent.push(cipher.getAuthTag());
            needs(frameSize === frameLength || (isFinalFrame && frameLength >= frameSize), 'Malformed frame');
            for (const cipherText of cipherContent) {
                if (!this.push(cipherText)) {
                    /* back pressure: if push returns false, wait until _read
                     * has been called.
                     */
                    await new Promise((resolve) => {
                        pathologicalDrain = resolve;
                    });
                }
            }
            if (isFinalFrame)
                this.push(null);
        }
    })();
}
export function getEncryptFrame(input) {
    const { pendingFrame, messageHeader, getCipher, isFinalFrame } = input;
    const { sequenceNumber, contentLength, content } = pendingFrame;
    const { frameLength, contentType, messageId, headerIvLength } = messageHeader;
    /* Precondition: The content length MUST correlate with the frameLength.
     * In the case of a regular frame,
     * the content length MUST strictly equal the frame length.
     * In the case of the final frame,
     * it MUST NOT be larger than the frame length.
     */
    needs(frameLength === contentLength ||
        (isFinalFrame && frameLength >= contentLength), `Malformed frame length and content length: ${JSON.stringify({
        frameLength,
        contentLength,
        isFinalFrame,
    })}`);
    const frameIv = serialize.frameIv(headerIvLength, sequenceNumber);
    const bodyHeader = Buffer.from(isFinalFrame
        ? finalFrameHeader(sequenceNumber, frameIv, contentLength)
        : frameHeader(sequenceNumber, frameIv));
    const contentString = aadUtility.messageAADContentString({
        contentType,
        isFinalFrame,
    });
    const { buffer, byteOffset, byteLength } = aadUtility.messageAAD(messageId, contentString, sequenceNumber, contentLength);
    const cipher = getCipher(frameIv);
    cipher.setAAD(Buffer.from(buffer, byteOffset, byteLength));
    return { content, cipher, bodyHeader, isFinalFrame };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWVkX2VuY3J5cHRfc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ZyYW1lZF9lbmNyeXB0X3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvRUFBb0U7QUFDcEUsc0NBQXNDO0FBRXRDLE9BQU8sRUFDTCxnQkFBZ0IsRUFDaEIsVUFBVSxFQUVWLE9BQU8sR0FDUixNQUFNLHVCQUF1QixDQUFBO0FBQzlCLGFBQWE7QUFDYixPQUFPLEVBQUUsU0FBUyxJQUFJLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUE7QUFFaEUsT0FBTyxFQUdMLEtBQUssR0FDTixNQUFNLHNDQUFzQyxDQUFBO0FBRTdDLE1BQU0sUUFBUSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQTtBQUM5RCxNQUFNLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUM1QyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLEdBQUcsU0FBUyxDQUFBO0FBQ25ELE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQWV2QyxNQUFNLHlCQUF5QixHQUFHLGlCQUVwQixDQUFBO0FBRWQsTUFBTSxNQUFNLEdBQUcsS0FBSyxJQUFJLEVBQUUsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUE7QUFDMUUsTUFBTSxJQUFJLEdBQUcsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFBLENBQUMsMkRBQTJEO0FBR2pGLE1BQU0sVUFBVSxzQkFBc0IsQ0FDcEMsU0FBb0IsRUFDcEIsYUFBNEIsRUFDNUIsT0FBaUIsRUFDakIsZUFBd0I7SUFFeEIsSUFBSSxpQkFBaUIsR0FBc0I7UUFDekMsYUFBYSxFQUFFLENBQUM7UUFDaEIsT0FBTyxFQUFFLEVBQUU7UUFDWCxjQUFjLEVBQUUsQ0FBQztLQUNsQixDQUFBO0lBQ0QsSUFBSSxpQkFBaUIsR0FBYSxJQUFJLENBQUE7SUFDdEMsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLGFBQWEsQ0FBQTtJQUVyQzs7O09BR0c7SUFDSCxLQUFLLENBQ0gsQ0FBQyxlQUFlO1FBQ2QsQ0FBQyxlQUFlLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSxlQUFlLENBQUMsRUFDeEUsZ0NBQWdDLENBQ2pDLENBQUE7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTyxJQUFJLENBQUMsTUFBTSxtQkFBb0IsU0FBUSx5QkFBeUI7UUFDckUsVUFBVSxDQUFDLEtBQWEsRUFBRSxRQUFnQixFQUFFLFFBQWlCO1lBQzNELE1BQU0sV0FBVyxHQUFHLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxhQUFhLENBQUE7WUFFakU7O2VBRUc7WUFDSCxLQUFLLENBQ0gsQ0FBQyxlQUFlLElBQUksQ0FBQyxlQUFlLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFDMUQsMENBQTBDLENBQzNDLENBQUE7WUFFRCwyRUFBMkU7WUFDM0UsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRTtnQkFDOUIsV0FBVztnQkFDWCxpQkFBaUIsQ0FBQyxhQUFhLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQTtnQkFDL0MsaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtnQkFDckMsT0FBTyxRQUFRLEVBQUUsQ0FBQTthQUNsQjtZQUVELGlCQUFpQixDQUFDLGFBQWEsSUFBSSxXQUFXLENBQUE7WUFDOUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFBO1lBRTNELGdCQUFnQjtZQUNoQixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFBO1lBRXJDLE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQztnQkFDbkMsWUFBWSxFQUFFLGlCQUFpQjtnQkFDL0IsYUFBYTtnQkFDYixTQUFTO2dCQUNULFlBQVksRUFBRSxLQUFLO2FBQ3BCLENBQUMsQ0FBQTtZQUVGLG1DQUFtQztZQUNuQyxNQUFNLEVBQUUsY0FBYyxFQUFFLEdBQUcsaUJBQWlCLENBQUE7WUFDNUMsaUJBQWlCLEdBQUc7Z0JBQ2xCLGFBQWEsRUFBRSxDQUFDO2dCQUNoQixPQUFPLEVBQUUsRUFBRTtnQkFDWCxjQUFjLEVBQUUsY0FBYyxHQUFHLENBQUM7YUFDbkMsQ0FBQTtZQUVELElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUM7aUJBQ2xDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7aUJBQ3JELEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUNwQixDQUFDO1FBRUQsTUFBTSxDQUFDLFFBQWlCO1lBQ3RCLE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQztnQkFDbkMsWUFBWSxFQUFFLGlCQUFpQjtnQkFDL0IsYUFBYTtnQkFDYixTQUFTO2dCQUNULFlBQVksRUFBRSxJQUFJO2FBQ25CLENBQUMsQ0FBQTtZQUVGLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUM7aUJBQ2xDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztpQkFDdEIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ3BCLENBQUM7UUFFRCxRQUFRO1lBQ04sT0FBTyxFQUFFLENBQUE7UUFDWCxDQUFDO1FBRUQsS0FBSyxDQUFDLElBQVk7WUFDaEIsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUNqQjs7Ozs7Ozs7OztlQVVHO1lBQ0gsaUJBQWlCLEVBQUUsQ0FBQTtZQUNuQixpQkFBaUIsR0FBRyxJQUFJLENBQUE7UUFDMUIsQ0FBQztRQUVELEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxlQUE2QjtZQUNwRCxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLEdBQUcsZUFBZSxDQUFBO1lBRXJFLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUE7WUFFckIsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFBO1lBQ2pCLE1BQU0sYUFBYSxHQUFhLEVBQUUsQ0FBQTtZQUNsQyxLQUFLLE1BQU0sVUFBVSxJQUFJLE9BQU8sRUFBRTtnQkFDaEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtnQkFDNUMsU0FBUyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUE7Z0JBQzlCLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUE7Z0JBQzlCLE1BQU0sTUFBTSxFQUFFLENBQUE7YUFDZjtZQUVELDhDQUE4QztZQUM5QyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUE7WUFDM0IsU0FBUyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUE7WUFDeEIsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN4QixpRUFBaUU7WUFDakUsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQTtZQUV2QyxLQUFLLENBQ0gsU0FBUyxLQUFLLFdBQVcsSUFBSSxDQUFDLFlBQVksSUFBSSxXQUFXLElBQUksU0FBUyxDQUFDLEVBQ3ZFLGlCQUFpQixDQUNsQixDQUFBO1lBRUQsS0FBSyxNQUFNLFVBQVUsSUFBSSxhQUFhLEVBQUU7Z0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO29CQUMxQjs7dUJBRUc7b0JBQ0gsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO3dCQUM1QixpQkFBaUIsR0FBRyxPQUFPLENBQUE7b0JBQzdCLENBQUMsQ0FBQyxDQUFBO2lCQUNIO2FBQ0Y7WUFFRCxJQUFJLFlBQVk7Z0JBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUNuQyxDQUFDO0tBQ0YsQ0FBQyxFQUFFLENBQUE7QUFDTixDQUFDO0FBU0QsTUFBTSxVQUFVLGVBQWUsQ0FBQyxLQUF3QjtJQUN0RCxNQUFNLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEdBQUcsS0FBSyxDQUFBO0lBQ3RFLE1BQU0sRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxHQUFHLFlBQVksQ0FBQTtJQUMvRCxNQUFNLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLEdBQUcsYUFBYSxDQUFBO0lBQzdFOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUNILFdBQVcsS0FBSyxhQUFhO1FBQzNCLENBQUMsWUFBWSxJQUFJLFdBQVcsSUFBSSxhQUFhLENBQUMsRUFDaEQsOENBQThDLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDM0QsV0FBVztRQUNYLGFBQWE7UUFDYixZQUFZO0tBQ2IsQ0FBQyxFQUFFLENBQ0wsQ0FBQTtJQUNELE1BQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLGNBQWMsQ0FBQyxDQUFBO0lBQ2pFLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQzVCLFlBQVk7UUFDVixDQUFDLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxFQUFFLE9BQU8sRUFBRSxhQUFhLENBQUM7UUFDMUQsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUUsT0FBTyxDQUFDLENBQ3pDLENBQUE7SUFDRCxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsdUJBQXVCLENBQUM7UUFDdkQsV0FBVztRQUNYLFlBQVk7S0FDYixDQUFDLENBQUE7SUFDRixNQUFNLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUM5RCxTQUFTLEVBQ1QsYUFBYSxFQUNiLGNBQWMsRUFDZCxhQUFhLENBQ2QsQ0FBQTtJQUNELE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUNqQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFBO0lBRTFELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsQ0FBQTtBQUN0RCxDQUFDIn0=