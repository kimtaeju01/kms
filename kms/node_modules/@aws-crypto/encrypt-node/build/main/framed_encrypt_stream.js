"use strict";
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const serialize_1 = require("@aws-crypto/serialize");
// @ts-ignore
const readable_stream_1 = require("readable-stream");
const material_management_node_1 = require("@aws-crypto/material-management-node");
const fromUtf8 = (input) => Buffer.from(input, 'utf8');
const serialize = serialize_1.serializeFactory(fromUtf8);
const { finalFrameHeader, frameHeader } = serialize;
const aadUtility = serialize_1.aadFactory(fromUtf8);
const PortableTransformWithType = readable_stream_1.Transform;
const ioTick = async () => new Promise((resolve) => setImmediate(resolve));
const noop = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
function getFramedEncryptStream(getCipher, messageHeader, dispose, plaintextLength) {
    let accumulatingFrame = {
        contentLength: 0,
        content: [],
        sequenceNumber: 1,
    };
    let pathologicalDrain = noop;
    const { frameLength } = messageHeader;
    /* Precondition: plaintextLength must be within bounds.
     * The Maximum.BYTES_PER_MESSAGE is set to be within Number.MAX_SAFE_INTEGER
     * See serialize/identifiers.ts enum Maximum for more details.
     */
    material_management_node_1.needs(!plaintextLength ||
        (plaintextLength >= 0 && serialize_1.Maximum.BYTES_PER_MESSAGE >= plaintextLength), 'plaintextLength out of bounds.');
    /* Keeping the messageHeader, accumulatingFrame and pathologicalDrain private is the intention here.
     * It is already unlikely that these values could be touched in the current composition of streams,
     * but a different composition may change this.
     * Since we are handling the plain text here, it seems prudent to take extra measures.
     */
    return new (class FramedEncryptStream extends PortableTransformWithType {
        _transform(chunk, encoding, callback) {
            const contentLeft = frameLength - accumulatingFrame.contentLength;
            /* Precondition: Must not process more than plaintextLength.
             * The plaintextLength is the MAXIMUM value that can be encrypted.
             */
            material_management_node_1.needs(!plaintextLength || (plaintextLength -= chunk.length) >= 0, 'Encrypted data exceeded plaintextLength.');
            /* Check for early return (Postcondition): Have not accumulated a frame. */
            if (contentLeft > chunk.length) {
                // eat more
                accumulatingFrame.contentLength += chunk.length;
                accumulatingFrame.content.push(chunk);
                return callback();
            }
            accumulatingFrame.contentLength += contentLeft;
            accumulatingFrame.content.push(chunk.slice(0, contentLeft));
            // grab the tail
            const tail = chunk.slice(contentLeft);
            const encryptFrame = getEncryptFrame({
                pendingFrame: accumulatingFrame,
                messageHeader,
                getCipher,
                isFinalFrame: false,
            });
            // Reset frame state for next frame
            const { sequenceNumber } = accumulatingFrame;
            accumulatingFrame = {
                contentLength: 0,
                content: [],
                sequenceNumber: sequenceNumber + 1,
            };
            this._flushEncryptFrame(encryptFrame)
                .then(() => this._transform(tail, encoding, callback))
                .catch(callback);
        }
        _flush(callback) {
            const encryptFrame = getEncryptFrame({
                pendingFrame: accumulatingFrame,
                messageHeader,
                getCipher,
                isFinalFrame: true,
            });
            this._flushEncryptFrame(encryptFrame)
                .then(() => callback())
                .catch(callback);
        }
        _destroy() {
            dispose();
        }
        _read(size) {
            super._read(size);
            /* The _flushEncryptFrame encrypts and pushes the frame.
             * If this.push returns false then this stream
             * should wait until the destination stream calls read.
             * This means that _flushEncryptFrame needs to wait for some
             * indeterminate time.  I create a closure around
             * the resolution function for a promise that
             * is created in _flushEncryptFrame.  This way
             * here in _read (the implementation of read)
             * if a frame is being pushed, we can release
             * it.
             */
            pathologicalDrain();
            pathologicalDrain = noop;
        }
        async _flushEncryptFrame(encryptingFrame) {
            const { content, cipher, bodyHeader, isFinalFrame } = encryptingFrame;
            this.push(bodyHeader);
            let frameSize = 0;
            const cipherContent = [];
            for (const clearChunk of content) {
                const cipherText = cipher.update(clearChunk);
                frameSize += cipherText.length;
                cipherContent.push(cipherText);
                await ioTick();
            }
            /* Finalize the cipher and handle any tail. */
            const tail = cipher.final();
            frameSize += tail.length;
            cipherContent.push(tail);
            /* Push the authTag onto the end.  Yes, I am abusing the name. */
            cipherContent.push(cipher.getAuthTag());
            material_management_node_1.needs(frameSize === frameLength || (isFinalFrame && frameLength >= frameSize), 'Malformed frame');
            for (const cipherText of cipherContent) {
                if (!this.push(cipherText)) {
                    /* back pressure: if push returns false, wait until _read
                     * has been called.
                     */
                    await new Promise((resolve) => {
                        pathologicalDrain = resolve;
                    });
                }
            }
            if (isFinalFrame)
                this.push(null);
        }
    })();
}
exports.getFramedEncryptStream = getFramedEncryptStream;
function getEncryptFrame(input) {
    const { pendingFrame, messageHeader, getCipher, isFinalFrame } = input;
    const { sequenceNumber, contentLength, content } = pendingFrame;
    const { frameLength, contentType, messageId, headerIvLength } = messageHeader;
    /* Precondition: The content length MUST correlate with the frameLength.
     * In the case of a regular frame,
     * the content length MUST strictly equal the frame length.
     * In the case of the final frame,
     * it MUST NOT be larger than the frame length.
     */
    material_management_node_1.needs(frameLength === contentLength ||
        (isFinalFrame && frameLength >= contentLength), `Malformed frame length and content length: ${JSON.stringify({
        frameLength,
        contentLength,
        isFinalFrame,
    })}`);
    const frameIv = serialize.frameIv(headerIvLength, sequenceNumber);
    const bodyHeader = Buffer.from(isFinalFrame
        ? finalFrameHeader(sequenceNumber, frameIv, contentLength)
        : frameHeader(sequenceNumber, frameIv));
    const contentString = aadUtility.messageAADContentString({
        contentType,
        isFinalFrame,
    });
    const { buffer, byteOffset, byteLength } = aadUtility.messageAAD(messageId, contentString, sequenceNumber, contentLength);
    const cipher = getCipher(frameIv);
    cipher.setAAD(Buffer.from(buffer, byteOffset, byteLength));
    return { content, cipher, bodyHeader, isFinalFrame };
}
exports.getEncryptFrame = getEncryptFrame;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWVkX2VuY3J5cHRfc3RyZWFtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ZyYW1lZF9lbmNyeXB0X3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0VBQW9FO0FBQ3BFLHNDQUFzQzs7QUFFdEMscURBSzhCO0FBQzlCLGFBQWE7QUFDYixxREFBZ0U7QUFFaEUsbUZBSTZDO0FBRTdDLE1BQU0sUUFBUSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQTtBQUM5RCxNQUFNLFNBQVMsR0FBRyw0QkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUM1QyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLEdBQUcsU0FBUyxDQUFBO0FBQ25ELE1BQU0sVUFBVSxHQUFHLHNCQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7QUFldkMsTUFBTSx5QkFBeUIsR0FBRywyQkFFcEIsQ0FBQTtBQUVkLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBO0FBQzFFLE1BQU0sSUFBSSxHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQSxDQUFDLDJEQUEyRDtBQUdqRixTQUFnQixzQkFBc0IsQ0FDcEMsU0FBb0IsRUFDcEIsYUFBNEIsRUFDNUIsT0FBaUIsRUFDakIsZUFBd0I7SUFFeEIsSUFBSSxpQkFBaUIsR0FBc0I7UUFDekMsYUFBYSxFQUFFLENBQUM7UUFDaEIsT0FBTyxFQUFFLEVBQUU7UUFDWCxjQUFjLEVBQUUsQ0FBQztLQUNsQixDQUFBO0lBQ0QsSUFBSSxpQkFBaUIsR0FBYSxJQUFJLENBQUE7SUFDdEMsTUFBTSxFQUFFLFdBQVcsRUFBRSxHQUFHLGFBQWEsQ0FBQTtJQUVyQzs7O09B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